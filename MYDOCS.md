# Проект 2: Лабиринты. Документация от создателя

## Описание

Проект состоит из реализации консольной программы для генерации лабиринтов и поиска пути в них. Программа способна генерировать лабиринты различной сложности и размеров, а также предоставляет два метода поиска пути от заданной точки А (начала) к точке Б (концу). Интерфейс приложения простой и понятный, с возможностью отрисовки в консоли лабиринта и найденного пути.

Подробности по реализации и использованию смотри ниже. Прочтение этой документации с большой вероятностью даст **ответы и пояснения** на многие вопросы, которые могут возникнуть во время работы с программой.

## Использование

### Справочная информация

- Для получения справочной информации по программу воспользуйтесь флагами `--help`, `-h` или запустите программу без аргументов.

```bash
go run ./cmd/app --help
go run ./cmd/app -h
go run ./cmd/app
```

- Для получения справочной информации по генерации и решению лабиринта воспользуйтесь флагами `--help`, `-h`.

```bash
go run ./cmd/app generate --help
go run ./cmd/app generate -h
go run ./cmd/app solve --help
go run ./cmd/app solve -h

```

### Генерация лабиринта

- Для генерации лабиринта используется команда `generate`.
- При остутствии каких-либо флагов генерация будет произведена по дефолтным параметрам, вывод осуществится в консоль:

```bash
go run ./cmd/app generate 
```

=

```bash
go run ./cmd/app generate -a dfs -W 10 -H 10 -u 0
```

#### Алгоритм

- Доступны два основных алгоритма генерации лабиринта: DFS, Prima.
- Доступно две возможные сложности лабиринта: лабиринт с однородными поверхностями, лабиринт с различными поверхностями.
- Для выбора алгоритма генерации используется флаг `-a, --algorithm` со следующими возможными значениями: `dfs`, `prim`, `dfs-enhanced`, `prim-enhanced`. При отсутствии флага используется дефолтный алгорит - DFS.
- Сложный лабиринт (`*-enhanced`) содержит четыре типа поверхностей, отличных от дефолтной: *coin*, *smooth*, *sand*, *swamp*. Две первые являются улучшающими и на великом и могучем значат *монеты* и *скользкая поверхность*. Аналогично две последние есть поверхности ухудшающие и являющие собой *песок* и *болото*.
- Веса поверхностей: *empty* = 10, *coin* = 5, *smooth* = 1, *sand* = 15, *swamp* = 20.

#### **Важное замечание**

Алгоритмы `dfs` и `prim` генерируют лабиринт ***без циклов***. При флаге `-a dfs-enhanced` или `-a prim-enhanced` в программе реализуется процедура `удаления стен`. Сделано это для того, чтобы имел возможность появиться лабиринт ***с циклами***. Циклы в лабиринте, в свою очередь, позволяют действительно выбрать оптимальный путь ***с учётом поверхностей***. Иначе путь будет существовать только один и наличие различных поверхностей ничего не меняет, а это не содержит под собой здравого смысла. Поэтому ***не пугайтесь***, если в лабиринте вдруг возникнут ***случайные одиночные стены или срезанные углы***. Алгоритмам решения это не помешает.


#### Размеры

- Доступны любые размеры лабиринта.
- Для выбора размера алгоритма используются флаги `-H, --height`(высота) и `-W, --weight`(ширина). При отсутствии флагов используется дефолтный размер 10х10.

#### **Важные замечания**

- Лабиринт генерируется с внешними и внутренними стенами ширины `1`. *Внутренние стены учитываются* в размере лабиринта. *Внешние - не учитываются*. Таким образом, лабиринт ниже сгенерирован с параметрами `-W 5 -H 3`.

```bash
#######
# #   #
# # ###
#     #
#######
```

- При базовой генерации лабиринта (*без unicode отображения*) на внешний вид лабиринта влияет четность размера. Это происходит из-за того, что шаг алгоритма генерации лабиринта - 2. Поэтому, если один из параметров лабиринта чётный (`-W 5 -H 4`), возникнет стена ширины `2`. Поэтому рекомендуется использовать нечётные параметры для красоты. Однако и использование чётных параметров корректно.

```bash
#######
# #   #
# # ###
#     #
#######
#######
```

- Про генерацию лабиринта *с использованием unicode* можно прочесть в разделе **Unicode**. 

#### Вывод лабиринта

- Вывод лабиринта может осуществлятся в консоль или в файл.
- Для вывода лабиринта в файл используются флаги `-o, --output` с последующим указанием пути для сохранения файла. При отсутствии флагов лабиринт выводится в консоль и не сохраняется.


#### Unicode

- Реализована псевдографика с использованием unicode-символов.
- Для включения псевдографики используются флаги `-u, --unicode` со следующими возможными значениями: `1`, `0`. При отсутствии флагов псевдографика не используется и флаг равен `0`.
- С использованием псевдографики лабиринт может как выводится в консоль, так и сохраняться в файл (см. п. **Вывод лабиринта**).

#### **Важные замечания**

- Программа **не умеет** читать лабиринт, сохранённый в файл, если он был сохранён **с использованием Unicode**.
- При использовании Unicode размеры лабиринта определяются следующим образом: `weight = 2 * W - 1`, `height = 2 * H - 1`, где `W` и `H` - ширина и высота лабиринта, указанные при генерации как значения флагов `-W`, `-H`. Сделано это для того, чтобы лабиринт в виде Unicode-символов визуально соответствовал размерам, заданным при генерации. 

```bash
go run ./cmd/app generate -a prim -W 4 -H 6 -u 1
```

```bash
┌───────┐     // Если такой лабиринт визуально разбить на клеточки,
│ ╷ ╷ ╶─┤     // то размер будет соответствовать указанному: ширина = 4, высота = 6
│ │ └─┐ │
│ │ ╷ └─┤
├─┘ ├─╴ │
├─╴ │ ╷ │
└───┴─┴─┘
```

- Фактически, при использовании Unicode стена визуально имеет ширину `0`, а не `1`, как раньше. Хотя в действительности лабиринт генерируется дефолтным образом. Для достижения этого мы как раз и увеличиваем размер лабиринта на количество стен (`W - 1`, `H - 1`). То есть фактически у нас сгенерировался вот такой лабиринт:

```
#########
#       #
# # # ###    // Его ширина = 7, высота = 13
# # #   #
# # ### #
# #   # #
# # # ###
# # #   #
### ### #
#   #   #
### # # #
#   # # #
#########
```

### Решение лабиринта

- Для решения лабиринта используется команда `solve`.
- При остутствии каких-либо флагов генерация будет выведена ошибка, поскольку дефолтно решать что-то не логично.

#### Алгоритм

- Доступны два основных алгоритма решения лабиринта: Dijkstra, Astar.
- Для выбора алгоритма решения используется флаг `-a, --algorithm` со следующими возможными значениями: `dijkstra`, `astar`. При отсутствии флага используется дефолтный алгорит - Dijkstra.
- Эти алгоритмы умеют решать как простой, так и сложный лабиринты.
- Dijkstra учитывает исключительно веса клеток. При обычной генерации (**без дополнительных поверхностей**) веса одинаковы. При генерации **с дополнительными поверхностями** веса различны.
- Astar под капотом вычисляет так называемую *эвристику* - `Манхетеннское расстояние(M) * min(weight)`. При обычной генерации (**без дополнительных поверхностей**) веса одинаковы и эвристика = `M * 10` (10 - вес дефолтной пустой ячейки). При генерации **с дополнительными поверхностями** веса различны и эвристика = `M * 1` (1 - вес самой "лёгкой" ячейки).
- Оба алгоритма фактически находят кратчайший путь в обычном лабиринте и "легчайший" путь в усложнённом лабиринте. Под легчайшим путём понимает путь с наименьшей возможной суммой весов по пройденным ячейкам.

#### Файл с лабиринтом

- При решении лабиринта необходимо указать файл, в котором этот лабиринт находится.
- Для указания файла с лабиринтом используется флаг `-f, --file` с последующим указанием пути к файлу. При отсутствии флага будет выведена ошибка.
- В случае, если лабиринт в файле некорректный, программа вернёт соотвествующую ошибку

**Важные замечания**

- Если лабиринт в файле записан в формате Unicode, программа ***вернёт ошибку***.
- В указанном файле лабиринт ***может иметь некорректные символы стен*** (крайние в каждом столбце и каждой строке). Но в случае, если внутри лабиринта есть некорректный символ, программа выведет ошибку.

```
#####
g   4     // Такой лабиринт программа прочитает (Но в решении внешние стены будут представляться символом #)
### Y
/   .
#.>q#
```

```
#####
#   #     // Такой лабиринт в файле вызовет ошибку
##g #
#   #
#####
```

#### Точки старта и конца пути

- При решении лабиринта необходимо указать точки старта и конца пути.
- Для указания точек старта используются флаги `-s, --start` и `-e, --end` с последующим указанием координат в формате `x,y`. При отсутствии флага будет выведена ошибка.
- При указании координат точек используйте 1-индексацию и не учитывайте внешние стены лабиринта.

```
maze1.txt
#####
#   #
### #
#   #
#####
```

```bash
go run ./cmd/app solve -f maze1.txt -s 1,1 -e 2,3
```

```
#####
#O..#
###.#
# X.#
#####
```

#### Вывод лабиринта

- Вывод решения лабиринта может осуществлятся в консоль или в файл.
- Для вывода решения лабиринта в файл используются флаги `-o, --output` с последующим указанием пути для сохранения файла. При отсутствии флагов лабиринт выводится в консоль и не сохраняется.

#### Unicode

- Реализована псевдографика с использованием unicode-символов.
- Для включения псевдографики используются флаги `-u, --unicode` со следующими возможными значениями: `1`, `0`. При отсутствии флагов псевдографика не используется и флаг равен `0`.
- С использованием псевдографики лабиринт может как выводится в консоль, так и сохраняться в файл (см. п. **Вывод лабиринта**).

#### **Важные замечания**

- Из-за нюансов работы с Unicode-символами лабиринт с путём в Unicode-формате будет выглядеть ***слегка "вытянуто"***. При этом корректность лабиринта, пути и отображения сохраняется. Вытянутость получается вследствие того, что иначе нам просто некуда вставить символы пути - Unicode-графика используется плотно по оси y.
- В силу особенностей псевдографики визуально размеры лабиринта тоже уменьшатся, но фактически всё будет корректно.

```
maze1.txt
#######
#     #    // Исходный лабиринт. В наших терминах имеет размеры ширина = 5, высота = 5
# # ###
# #   #
### # #
#   # #
#######
```

```bash
go run ./cmd/app solve -f maze1.txt -s 1,1 -e 5,5 -u 1
```

```
┌─────┐
│O..  │
│ ╷.╶─┤    // 1. Лабиринт слегка вытянулся
│ │...│    // 2. Визуально (если выделить клеточки) он выглядит 3 на 3. Но если присмотреться он полностью  
├─┘ ╷.│    //    соответствует исходному лабиринту.
│   │X│
└───┴─┘
```

- Да, для единообразия можно было бы генерировать и лабиринт без пути "вытянутым", но для красоты нельзя было.

## Реализация 

Про основные тонкости реализации было рассказано выше. Осталось сказать про тесты BlackBox и основные изменения, которые были туда внесены. 

### BlackBox

- Запуск тестов осуществлялся из папки, в которой находился весь проект.
- Запуск тестов осуществлялся на машине Windows.
- Тесты были изменены так, чтобы они проходили локально, посему у меня нету уверенности, что на другой машине (например, на маке) всё пройдёт гладко. Тем не менее логика тестов сохранена, лабиринты сохранены.
- **Test1**: Немного изменён вид справки. Были проблемы с переводом строк. Вручную они изменены в программе на вид \r\n. Всё ещё не совсем понимаю, почему падало... Изменён путь (начало с ./)
- **Test2**: Изменён текст ошибки. Изменён путь (начало с ./)
- **Test3**: Стены в лабиринте исправлены на одинарные. Изменён путь (начало с ./)
- **Test4**: Стены в лабиринте исправлены на одинарные. Изменён путь (начало с ./)


